import _extends from "@babel/runtime/helpers/extends";
import _typeof from "@babel/runtime/helpers/typeof";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["children", "MenuProps", "LabelProps", "InputProps", "error", "label", "hint", "value", "noOptionsText", "focusOnOpen", "onChange", "onOpen", "onClose", "getOptionDisabled", "multiple", "size", "disabled", "options", "background", "placeholder", "fullWidth"];
import React, { useRef, useEffect, useState } from 'react';
import PT from 'prop-types';
import Cross from '@scaleflex/icons/cross';
import { intrinsicComponent, objectValues } from '../../utils/functions';
import { propTypes as labelPropTypes } from '../label/label.component';
import { propTypes as inputPropTypes } from '../input/input.component';
import Label from '../label';
import FormHint from '../form-hint';
import ArrowTick from '../arrow-tick';
import Input from '../input';
import Menu from '../menu';
import MenuItem from '../menu-item'; // TODO: refactor how implement tags in input
// import Tag from '../tag';

import { InputBackgroundColor, InputSize } from '../../utils/types';
import Styled from './autocomplete.styles';
var Autocomplete = intrinsicComponent(function (_ref, ref) {
  var children = _ref.children,
      MenuProps = _ref.MenuProps,
      LabelPropsData = _ref.LabelProps,
      InputPropsData = _ref.InputProps,
      error = _ref.error,
      label = _ref.label,
      hint = _ref.hint,
      value = _ref.value,
      _ref$noOptionsText = _ref.noOptionsText,
      noOptionsText = _ref$noOptionsText === void 0 ? 'No options' : _ref$noOptionsText,
      focusOnOpen = _ref.focusOnOpen,
      onChange = _ref.onChange,
      onOpen = _ref.onOpen,
      onClose = _ref.onClose,
      getOptionDisabled = _ref.getOptionDisabled,
      multiple = _ref.multiple,
      size = _ref.size,
      disabled = _ref.disabled,
      options = _ref.options,
      background = _ref.background,
      placeholder = _ref.placeholder,
      fullWidth = _ref.fullWidth,
      rest = _objectWithoutProperties(_ref, _excluded);

  var inputRef = useRef(null);

  var _useState = useState(multiple ? [] : ''),
      _useState2 = _slicedToArray(_useState, 2),
      selected = _useState2[0],
      setSelected = _useState2[1];

  var _useState3 = useState(options),
      _useState4 = _slicedToArray(_useState3, 2),
      filteredOptions = _useState4[0],
      setFilteredOptions = _useState4[1];

  var _useState5 = useState(undefined),
      _useState6 = _slicedToArray(_useState5, 2),
      anchorEl = _useState6[0],
      setAnchorEl = _useState6[1];

  var _useState7 = useState(-1),
      _useState8 = _slicedToArray(_useState7, 2),
      currentItemIndex = _useState8[0],
      setCurrentItemIndex = _useState8[1];

  var open = Boolean(anchorEl);
  var isItemSelected = selected.length > 0;

  var handleOnChange = function handleOnChange(event, val) {
    if (multiple) {
      if (onChange) {
        onChange(event, [].concat(_toConsumableArray(selected), [val]));
      }
    } else {
      if (onChange) {
        onChange(event, val);
      }

      setSelected('');
      setCurrentItemIndex(-1);
    }
  }; // TODO: refactor how implement tags in input
  // const handleOnRemoveItem = (event: any, itemIndex: number): void => {
  //   const updatedSelectedItems = Array.isArray(selected)
  //     ? selected.filter((_, index: number) => index !== itemIndex)
  //     : '';
  //   setSelected(updatedSelectedItems);
  //   if (onChange) {
  //     onChange(event, updatedSelectedItems);
  //   }
  // };


  var handleOpenClick = function handleOpenClick(event) {
    setAnchorEl(inputRef.current);

    if (onOpen) {
      onOpen(event);
    }
  };

  var handleCloseClick = function handleCloseClick(event) {
    setAnchorEl(undefined);
    setCurrentItemIndex(-1);

    if (onClose) {
      onClose(event);
    }
  };

  var handleClearIconClick = function handleClearIconClick(event) {
    event === null || event === void 0 ? void 0 : event.stopPropagation();

    if (multiple) {
      if (onChange) {
        onChange(event, []);
      }

      setSelected([]);
    } else {
      if (onChange) {
        onChange(event, '');
      }

      setSelected('');
      setCurrentItemIndex(-1);
    }
  };

  var handleSelectedItem = function handleSelectedItem(event, item) {
    // make sure this item isn't already selected
    if (!multiple && selected !== item) {
      handleOnChange(event, item);

      if (multiple) {
        setSelected(function (prev) {
          return [].concat(_toConsumableArray(prev), [item]);
        });
      } else {
        setSelected(item);
      }
    }

    handleCloseClick(event);
  };

  var handleMenuItemClick = function handleMenuItemClick(event, item, index) {
    // menu item shouldn't be clickable if it's disabled or = 'No options'
    if (item === noOptionsText || getOptionDisabled && getOptionDisabled(item, index)) {
      return undefined;
    }

    return handleSelectedItem(event, item);
  };

  var getValue = function getValue() {
    if (multiple) {
      var lastValue = value[value.length - 1];

      if (selected.includes(lastValue)) {
        return '';
      }

      return lastValue;
    }

    return value;
  };

  var handleInputChange = function handleInputChange(event) {
    handleOnChange(event, event.currentTarget.value);
    setAnchorEl(inputRef.current);
  };

  var getOptionIndex = function getOptionIndex(option) {
    var optionIndex = -1;

    if (_typeof(options[0]) === 'object') {
      var optionObject = Object.entries(options).find(function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2),
            _ = _ref3[0],
            optObject = _ref3[1];

        return optObject.label === option;
      });

      if (optionObject) {
        optionIndex = Number(optionObject[0]);
      }
    } else {
      optionIndex = options.indexOf(option);
    }

    return optionIndex;
  };

  var getNextAvailableOption = function getNextAvailableOption(currentIndex, direction) {
    while (currentIndex !== currentItemIndex) {
      var selectedOption = filteredOptions[currentIndex];
      var optionIndex = getOptionIndex(selectedOption);
      var isDisabled = false;

      if (getOptionDisabled && typeof selectedOption === 'string') {
        isDisabled = getOptionDisabled(selectedOption, optionIndex);
      }

      if (!isDisabled) {
        setCurrentItemIndex(currentIndex);
        break;
      }

      if (direction === 'ArrowUp') {
        if (currentIndex === 0) {
          currentIndex = filteredOptions.length;
        }

        currentIndex -= 1;
      }

      if (direction === 'ArrowDown') {
        if (currentIndex === filteredOptions.length - 1) {
          currentIndex = -1;
        }

        currentIndex += 1;
      }
    }
  };

  var handleKeyDown = function handleKeyDown(event) {
    if (open) {
      if (event.key === 'ArrowUp') {
        if (currentItemIndex > 0) {
          getNextAvailableOption(currentItemIndex - 1, event.key);
        } else {
          getNextAvailableOption(filteredOptions.length - 1, event.key);
        }
      }

      if (event.key === 'ArrowDown') {
        if (currentItemIndex < filteredOptions.length - 1) {
          getNextAvailableOption(currentItemIndex + 1, event.key);
        } else {
          getNextAvailableOption(0, event.key);
        }
      }

      if (event.key === 'Enter' && currentItemIndex >= 0) {
        var selectedOption = filteredOptions[currentItemIndex];

        if (typeof selectedOption === 'string') {
          handleSelectedItem(event, selectedOption);
        }
      }

      if (event.key === 'Escape') {
        handleCloseClick(event);
      }
    }
  }; // TODO: refactor how implement tags in input
  // const getMultipleFilteredOptions = (): void => {
  //   if (isItemSelected) {
  //     // lastValue = selectedItem | enteredValue
  //     // ["item1","ite"]
  //     const lastValue = value[value.length - 1];
  //     const filteredMenuOptions = selected.includes(lastValue)
  //       ? options
  //       : options?.filter((option: string) => option.includes(lastValue));
  //     setFilteredOptions(filteredMenuOptions || []);
  //   } else {
  //     // filter menu options based on the value[0] as it's an array in multiple mode
  //     const filteredMenuOptions = options?.filter((option: any) => option.includes(value[0]));
  //     setFilteredOptions(filteredMenuOptions || []);
  //   }
  // };


  var getFilteredOptions = function getFilteredOptions() {
    var filteredMenuOptions = _typeof(options[0]) === 'object' ? options.map(function (option) {
      return option.label;
    }) : options;

    if (!isItemSelected) {
      filteredMenuOptions = filteredMenuOptions.filter(function (option) {
        return option.includes(value);
      });
    }

    setFilteredOptions(filteredMenuOptions || []);
  };

  var renderLabel = function renderLabel() {
    if (label) {
      if (typeof label === 'function') {
        return label({
          error: error
        });
      }

      if (_typeof(label) === 'object') {
        return label;
      }

      return /*#__PURE__*/React.createElement(Label, _extends({
        error: error
      }, LabelPropsData || {}), label);
    }

    return null;
  }; // TODO: refactor how implement tags in input
  // const renderTags = (): JSX.Element[] | JSX.Element | boolean | undefined => {
  //   if (multiple && isItemSelected && Array.isArray(selected)) {
  //     return selected.map((item: string, index: number) => (
  //       <Tag
  //         key={index}
  //         tagIndex={index}
  //         style={{ margin: '0px 4px 4px 0px' }}
  //         onRemove={(_, event) => handleOnRemoveItem(event, index)}
  //       >
  //         {item}
  //       </Tag>
  //     ));
  //   }
  // };


  var renderHint = function renderHint() {
    if (hint) {
      if (typeof hint === 'function') {
        return hint({
          error: error
        });
      }

      if (_typeof(hint) === 'object') {
        return hint;
      }

      return /*#__PURE__*/React.createElement(FormHint, {
        error: error
      }, hint);
    }

    return null;
  };

  var renderMenuItem = function renderMenuItem(item, index) {
    var optionIndex = getOptionIndex(item);
    return /*#__PURE__*/React.createElement(MenuItem, {
      key: optionIndex,
      value: item,
      noOptionsText: item === noOptionsText,
      disabled: getOptionDisabled && getOptionDisabled(item, optionIndex),
      active: multiple && selected.includes(item) || item === selected || index === currentItemIndex,
      onClick: function onClick(event) {
        return handleMenuItemClick(event, item, optionIndex);
      },
      enableScrollIntoView: true
    }, item);
  };

  useEffect(function () {
    if (focusOnOpen) setAnchorEl(inputRef.current);
  }, [focusOnOpen]);
  useEffect(function () {
    if (isItemSelected) {
      filteredOptions.map(function (option, index) {
        if (option === selected) {
          setCurrentItemIndex(index);
        }

        return null;
      });
    }
  }, [anchorEl]);
  useEffect(function () {
    if (multiple && (value === null || value === void 0 ? void 0 : value.length) > 0) {// TODO: refactor how implement tags in input
      // getMultipleFilteredOptions();
    } else {
      getFilteredOptions();
    }
  }, [value, anchorEl]);
  useEffect(function () {
    if ((filteredOptions === null || filteredOptions === void 0 ? void 0 : filteredOptions.length) === 0) {
      setFilteredOptions([noOptionsText]);
    }
  }, [filteredOptions, value]);
  return /*#__PURE__*/React.createElement(Styled.Autocomplete, _extends({
    ref: ref
  }, rest), renderLabel(), /*#__PURE__*/React.createElement(Styled.AutocompleteContainer, {
    onClick: disabled ? undefined : handleOpenClick
  }, /*#__PURE__*/React.createElement(Input, _extends({}, InputPropsData || {}, {
    ref: inputRef,
    size: size,
    value: getValue() // TODO: refactor how implement tags in input
    // renderTags={renderTags()}
    ,
    readOnly: disabled,
    focusOnMount: focusOnOpen,
    background: background,
    onKeyDown: handleKeyDown,
    onChange: handleInputChange,
    placeholder: placeholder,
    fullWidth: fullWidth,
    iconEnd: function iconEnd() {
      return /*#__PURE__*/React.createElement(ArrowTick, {
        onClick: disabled ? undefined : handleOpenClick,
        type: open ? 'top' : 'bottom',
        IconProps: {
          size: 10
        }
      });
    },
    clearIcon: isItemSelected && /*#__PURE__*/React.createElement(Cross, {
      size: 12
    }),
    clearIconClick: handleClearIconClick
  }))), /*#__PURE__*/React.createElement(Menu, _extends({
    onClose: handleCloseClick,
    open: open,
    anchorEl: anchorEl,
    style: {
      maxHeight: '250px'
    }
  }, MenuProps), _typeof(filteredOptions[0]) === 'object' ? Object.values(filteredOptions).map(function (option, index) {
    return renderMenuItem(option.label, index);
  }) : filteredOptions === null || filteredOptions === void 0 ? void 0 : filteredOptions.map(function (item, index) {
    return renderMenuItem(item, index);
  })), renderHint());
});
Autocomplete.defaultProps = {
  size: InputSize.Md,
  background: InputBackgroundColor.Primary,
  // multiple: false,
  disabled: false
};
Autocomplete.propTypes = {
  children: PT.oneOfType([PT.element, PT.arrayOf(PT.element)]),
  size: PT.oneOf(objectValues(InputSize)),
  LabelProps: PT.exact(labelPropTypes),
  InputProps: PT.exact(inputPropTypes),
  background: PT.oneOf(objectValues(InputBackgroundColor)),
  value: PT.oneOfType([PT.string, PT.array]).isRequired,
  label: PT.node,
  hint: PT.node,
  options: PT.array.isRequired,
  noOptionsText: PT.string,
  placeholder: PT.string,
  fullWidth: PT.bool,
  multiple: PT.bool,
  disabled: PT.bool,
  focusOnOpen: PT.bool,
  error: PT.bool,
  onChange: PT.func,
  onOpen: PT.func,
  onClose: PT.func,
  getOptionDisabled: PT.func
};
export default Autocomplete;